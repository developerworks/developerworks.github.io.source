title: (译)理解Elixir宏第2部分
categories:
  - Elixir
tags:
  - Elixir
toc: false
date: 2014-12-18 15:45:38
---

这是理解Elixir宏系列文章的第二篇. [上一篇](/2014/12/18/elixir-understanding-macro-part-1/)讨论了`编译阶段`和`Elixir宏`

## 调用宏

要知道在编译过程的展开阶段最重要的事情是: 编译器调用各种宏(以及其他代码生成构造), 并产生最终的AST.

例如, 一个经典的对`trace`宏的使用示例如下:

```
# 定义了我们的应用模块
defmodule MyModule do
  # 包含了我们需要用到的代码调试和追踪模块
  require Tracer
  ...
  def some_fun(...) do
    # 调用具体的追踪模块调试代码
    Tracer.trace(...)
  end
end
```

## Hygiene

## 宏参数



## 揉到一起

## 使用模块

查看上面的代码, 函数`match/2`是在客户端模块中实现. 这确实是太不完美了, 因为每个客户端模块都必须提供该函数的正确实现,并知道`do_match`函数如何调用.

如果`Plug.Router`能够提供`match/2`的实现是不是更好. 对此我们可以采用`use`宏, 它初略地等同于其他语言中的Mixin.

普遍的思想是:

```
# 客户端模块部分
defmodule ClientCode do
  # invokes the mixin
  use GenericCode, option_1: value_1, option_2: value_2, ...
end
# 通用代码部分
defmodule GenericCode do
  # called when the module is used
  defmacro __using__(options) do
    # generates an AST that will be inserted in place of the use
    quote do
      ...
    end
  end
end
```

`use`机制允许我们在调用者的上下文种注入代码, 这类似于如下这种替代形式:

```
defmodule ClientCode do
    # 加载通用模块
    require GenericCode
    # 调用通用模块中的公共函数
    GenericCode.__using__(...)
end
```

其可以通过`use`宏的[Elixir实现源代码](https://github.com/elixir-lang/elixir/blob/v0.14.0/lib/elixir/lib/kernel.ex#L3531-L3532)得到证明. 同时还证明了另一点 - 增量展开.

`use`宏生成了调用其他宏的代码. 说的更明白一点, `use`生成了用于生成代码的代码(use生成了代码,生成的代码又用于生成其他的代码), 早前我们曾说过, 编译器会递归地展开它所发现的所有宏定义, 直到没有可展开的宏为止.

拥有了这方面的知识, 现在可以转移到`Plug.Router`通用模块的`match`函数的实现.

```
defmodule Plug.Router do
  defmacro __using__(_options) do
    # 译注:
    # 在调用者use本模块的时候返回一个AST结构,并插入到use被使用的位置
    # 如果你有Web的开发经验, 类似于在DOM树中插入一个子树或子节点,用于改变整个DOM树的结构,
    # 类似的__using__宏返回一个AST片段, 并插入到调用代码的位置, 也就是在客户端模块中`use`宏使用的位置
    quote do
      # 导入自身, 以便在客户端代码中不必以`Plug.Router.get`的形式使用,而是直接使用`get`
      import Plug.Router
      def match(type, route) do
        do_match(type, route, :dummy_connection)
      end
    end
  end
  defmacro get(route, body) do
    ... # 这里的代码保持原样
  end
end
```

这样, 我们就可以把客户端模块的代码保持的非常苗条:

```
defmodule MyRouter do
  # 使用Plug.Router模块,同时在编译阶段(具体实际上是展开阶段),运行该模块中的`__using__`宏,
  # 并把`__using__`返回的AST片段插入到当前位置
  use Plug.Router
  get "/hello", do: {conn, "Hi!"}
  get "/goodbye", do: {conn, "Bye!"}
end
```

前面曾提到, 由`__using__`宏生成的AST片段只是简单地插入到`use Plug.Router`调用的位置. 特别注意的是, 在`__use___`宏定义中的`import Plug.Router`, 严格意义上并不需要这行代码, 它只是使客户端代码变得更加简洁一些, 你可以使用`get`, 而不必输入其全称`Plug.Router.get`.

下面这段就不译了, 一堆废话, 看得懂的看, 看不懂的可以忽略.

So what have we gained? The various boilerplate is now confined to the single place (`Plug.Router`).
Not only does this simplify the client code, it also keeps the abstraction properly closed.
The module `Plug.Router` ensures that whatever is generated by get macros fits properly with the generic code of `match`.
As clients, we simply use the module and call into the provided macros to assemble our router.

This concludes today's session. Many details are not covered,
but hopefully you have a better understanding of how macros integrate with the Elixir compiler.
In the next part I'll dive deeper and start exploring how we can tear apart the input AST.

## 译注

对于`use`的使用我们可以理解为:

- PHP中的`require 'database.php'`和`include 'database.php'`
- Java中的`import com.mysql.jdbc.Driver;`
- Python中的`import amqp`
- C中的`include <stdlib.h>`

它是在编译过程中的展开阶段对代码(AST)进行修改和装饰, 并把修改过的代码(AST)插入到使用的位置.

## 原文

http://www.theerlangelist.com/2014/06/understanding-elixir-macros-part-2.html